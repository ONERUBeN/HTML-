<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DEEP DUNGEON</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --bg: #111;
            --ui: #222;
            --text: #eee;
            --accent: #d4af37;
        }

        body {
            margin: 0; overflow: hidden; background: var(--bg);
            font-family: 'VT323', monospace; color: var(--text);
            user-select: none; -webkit-tap-highlight-color: transparent;
            display: flex; flex-direction: column; height: 100vh;
        }

        /* SCREENS */
        .screen {
            position: fixed; inset: 0; background: var(--bg);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 10;
        }
        .screen.active { display: flex; }

        /* MENU */
        h1 { font-size: 40px; color: var(--accent); margin-bottom: 20px; text-shadow: 2px 2px 0 #000; }
        .hero-select { display: flex; gap: 10px; margin-bottom: 20px; }
        .hero-card {
            border: 2px solid #444; padding: 10px; border-radius: 8px; cursor: pointer;
            text-align: center; width: 80px; transition: 0.2s;
        }
        .hero-card.selected { border-color: var(--accent); background: rgba(212, 175, 55, 0.1); }
        .hero-icon { font-size: 30px; }

        /* GAME UI */
        #game-ui {
            position: absolute; top: 0; left: 0; width: 100%; padding: 10px;
            display: flex; justify-content: space-between; z-index: 5;
            background: rgba(0,0,0,0.8); border-bottom: 1px solid #333;
        }
        .bar-box { width: 100px; height: 10px; background: #333; margin-top: 5px; }
        .hp-fill { height: 100%; background: #e74c3c; width: 100%; transition: width 0.2s; }
        .xp-fill { height: 100%; background: #3498db; width: 0%; transition: width 0.2s; }

        /* CANVAS */
        #canvas-container { flex: 1; position: relative; overflow: hidden; display: flex; justify-content: center; align-items: center; background: #000; }
        canvas { image-rendering: pixelated; }

        /* CONTROLS */
        .d-pad {
            position: absolute; bottom: 20px; width: 100%; height: 180px;
            display: flex; justify-content: center; align-items: center;
            z-index: 5; pointer-events: none;
        }
        .pad-row { display: flex; justify-content: center; width: 100%; }
        .pad-btn {
            width: 60px; height: 60px; background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2); border-radius: 10px;
            margin: 5px; pointer-events: auto; display: flex;
            align-items: center; justify-content: center; font-size: 24px;
        }
        .pad-btn:active { background: rgba(255,255,255,0.3); }
        
        .action-btn {
            position: absolute; bottom: 40px; right: 20px;
            width: 70px; height: 70px; border-radius: 50%;
            background: rgba(212, 175, 55, 0.2); border: 2px solid var(--accent);
            color: var(--accent); font-size: 14px; pointer-events: auto;
            display: flex; align-items: center; justify-content: center; font-weight: bold;
        }

        /* LOG */
        #log {
            position: absolute; bottom: 220px; left: 10px; width: 90%;
            height: 60px; pointer-events: none; overflow: hidden;
            font-size: 14px; text-shadow: 1px 1px 0 #000;
            display: flex; flex-direction: column-reverse;
        }
        .log-msg { margin-top: 2px; opacity: 0.8; }

        /* MODAL */
        .modal-bg { position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 20; display:none; align-items:center; justify-content:center; flex-direction:column; }
        .btn { padding: 10px 20px; background: var(--accent); color: #000; border: none; font-family: inherit; font-size: 18px; cursor: pointer; margin-top: 10px; }

    </style>
</head>
<body>

    <div id="menu" class="screen active">
        <h1>DEEP DUNGEON</h1>
        <div style="margin-bottom:20px">–í–´–ë–ï–†–ò –ì–ï–†–û–Ø:</div>
        <div class="hero-select">
            <div class="hero-card selected" onclick="selectClass('KNIGHT', this)">
                <div class="hero-icon">üõ°</div>
                <div>KNIGHT</div>
            </div>
            <div class="hero-card" onclick="selectClass('ROGUE', this)">
                <div class="hero-icon">üó°</div>
                <div>ROGUE</div>
            </div>
            <div class="hero-card" onclick="selectClass('MAGE', this)">
                <div class="hero-icon">üî•</div>
                <div>MAGE</div>
            </div>
        </div>
        <div style="margin-bottom:20px; color:#aaa;" id="menu-stats">HP: 100 | ATK: 5</div>
        <button class="btn" onclick="startGame()">START RUN</button>
        <button class="btn" style="background:#444; color:#fff; margin-top:10px;" onclick="showShop()">SHOP</button>
    </div>

    <div id="game" class="screen">
        <div id="game-ui">
            <div>
                <div id="ui-hp">HP 100/100</div>
                <div class="bar-box"><div class="hp-fill" id="bar-hp"></div></div>
            </div>
            <div style="text-align:right">
                <div id="ui-gold">üí∞ 0</div>
                <div style="font-size:12px; color:#aaa" id="ui-depth">FLOOR 1</div>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="cvs"></canvas>
        </div>

        <div id="log"></div>

        <div class="d-pad">
            <div style="display:flex; flex-direction:column; align-items:center;">
                <div class="pad-btn" onclick="move(0, -1)">‚¨ÜÔ∏è</div>
                <div style="display:flex;">
                    <div class="pad-btn" onclick="move(-1, 0)">‚¨ÖÔ∏è</div>
                    <div class="pad-btn" onclick="move(0, 1)">‚¨áÔ∏è</div>
                    <div class="pad-btn" onclick="move(1, 0)">‚û°Ô∏è</div>
                </div>
            </div>
        </div>
        
        <div class="action-btn" onclick="playerAction()">ATTACK</div>
    </div>

    <div id="modal-shop" class="modal-bg">
        <h2 style="color:gold">GEM SHOP</h2>
        <button class="btn" onclick="buyGems(100, 50)">100 GEMS (50‚≠ê)</button>
        <button class="btn" onclick="buyGems(500, 200)">500 GEMS (200‚≠ê)</button>
        <button class="btn" style="background:#444; color:#fff" onclick="document.getElementById('modal-shop').style.display='none'">CLOSE</button>
    </div>

    <script>
        const tg = window.Telegram.WebApp;
        tg.expand();

        // --- ENGINE CONFIG ---
        const TILE = 32;
        const VIEW_W = 11; // Tiles visible horizontally
        const VIEW_H = 13; // Tiles visible vertically
        
        const cvs = document.getElementById('cvs');
        const ctx = cvs.getContext('2d');
        
        // --- ASSETS (EMOJI BASED FOR SPEED) ---
        const SPRITES = {
            wall: '#333',
            floor: '#111',
            player: 'üõ°',
            enemy_slime: 'ü¶†',
            enemy_skel: 'üíÄ',
            enemy_boss: 'üëπ',
            chest: 'üì¶',
            stairs: 'üö™',
            gold: 'üí∞'
        };

        // --- STATE ---
        let heroClass = 'KNIGHT';
        let player = { x:1, y:1, hp:100, maxHp:100, atk:5, gold:0, depth:1 };
        let map = [];
        let entities = [];
        let particles = [];
        let mapW = 20, mapH = 20;
        let camX = 0, camY = 0;

        // --- SETUP ---
        function initCanvas() {
            cvs.width = TILE * VIEW_W;
            cvs.height = TILE * VIEW_H;
            ctx.font = `${TILE-4}px sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
        }

        function selectClass(cls, el) {
            heroClass = cls;
            document.querySelectorAll('.hero-card').forEach(e => e.classList.remove('selected'));
            el.classList.add('selected');
            
            let stats = "HP: 100 | ATK: 5";
            if(cls === 'ROGUE') stats = "HP: 70 | ATK: 12 (CRIT)";
            if(cls === 'MAGE') stats = "HP: 60 | ATK: 8 (RANGE)";
            document.getElementById('menu-stats').innerText = stats;
        }

        function startGame() {
            document.getElementById('menu').classList.remove('active');
            document.getElementById('game').classList.add('active');
            
            // Set stats based on class
            player.maxHp = heroClass === 'KNIGHT' ? 120 : (heroClass === 'ROGUE' ? 70 : 60);
            player.hp = player.maxHp;
            player.atk = heroClass === 'KNIGHT' ? 5 : (heroClass === 'ROGUE' ? 10 : 8);
            player.gold = 0;
            player.depth = 1;
            
            tg.sendData(JSON.stringify({act:'set_class', class:heroClass}));
            initCanvas();
            generateLevel();
            loop();
        }

        // --- GENERATION (Simple Cellular Automata) ---
        function generateLevel() {
            mapW = 20 + player.depth * 2; // Bigger maps deeper
            mapH = 20 + player.depth * 2;
            map = [];
            entities = [];
            
            // 1. Fill Wall
            for(let y=0; y<mapH; y++) {
                let row = [];
                for(let x=0; x<mapW; x++) row.push(1);
                map.push(row);
            }

            // 2. Carve Rooms (Random Walk)
            let digX = Math.floor(mapW/2), digY = Math.floor(mapH/2);
            player.x = digX; player.y = digY;
            
            let floorCount = 0;
            let targetFloors = (mapW*mapH) * 0.4;
            
            while(floorCount < targetFloors) {
                if(map[digY][digX] === 1) {
                    map[digY][digX] = 0;
                    floorCount++;
                }
                
                // Random move
                let dir = Math.floor(Math.random()*4);
                if(dir===0 && digY>1) digY--;
                if(dir===1 && digY<mapH-2) digY++;
                if(dir===2 && digX>1) digX--;
                if(dir===3 && digX<mapW-2) digX++;
            }

            // 3. Populate
            for(let y=0; y<mapH; y++) {
                for(let x=0; x<mapW; x++) {
                    if(map[y][x] === 0 && (x!==player.x || y!==player.y)) {
                        let roll = Math.random();
                        if(roll < 0.05) spawnEntity('slime', x, y);
                        else if(roll < 0.08 && player.depth > 2) spawnEntity('skel', x, y);
                        else if(roll < 0.02) spawnEntity('chest', x, y);
                    }
                }
            }
            
            // Exit
            let exitSet = false;
            while(!exitSet) {
                let ex = Math.floor(Math.random()*mapW);
                let ey = Math.floor(Math.random()*mapH);
                if(map[ey][ex] === 0 && Math.abs(ex-player.x) > 5) {
                    map[ey][ex] = 2; // Stairs
                    exitSet = true;
                }
            }
            
            log(`Entered Floor ${player.depth}`);
            updateUI();
        }

        function spawnEntity(type, x, y) {
            let hp = 20, atk = 3, icon = SPRITES.enemy_slime;
            if(type === 'skel') { hp = 40; atk = 6; icon = SPRITES.enemy_skel; }
            if(type === 'chest') { hp = 1; atk = 0; icon = SPRITES.chest; }
            
            // Scale with depth
            hp += player.depth * 5;
            atk += Math.floor(player.depth / 2);

            entities.push({ type, x, y, hp, maxHp:hp, atk, icon });
        }

        // --- GAMEPLAY ---
        function move(dx, dy) {
            let tx = player.x + dx;
            let ty = player.y + dy;

            // Wall check
            if(map[ty][tx] === 1) return;

            // Entity check
            let target = entities.find(e => e.x === tx && e.y === ty);
            if(target) {
                attack(target);
                return;
            }

            // Stairs check
            if(map[ty][tx] === 2) {
                player.depth++;
                generateLevel();
                return;
            }

            player.x = tx;
            player.y = ty;
            tick();
        }

        function attack(target) {
            if(target.type === 'chest') {
                let loot = Math.floor(Math.random()*50) + 10;
                player.gold += loot;
                log(`Found ${loot} Gold!`);
                spawnParticle(target.x, target.y, `+${loot}üí∞`, '#ff0');
                // Remove chest
                entities = entities.filter(e => e !== target);
                updateUI();
                return;
            }

            // Combat
            let dmg = player.atk;
            if(heroClass === 'ROGUE' && Math.random() < 0.3) {
                dmg *= 2; // Crit
                spawnParticle(target.x, target.y, "CRIT!", "#f00");
            }
            
            target.hp -= dmg;
            spawnParticle(target.x, target.y, `-${dmg}`, "#fff");
            tg.HapticFeedback.impactOccurred('medium');

            if(target.hp <= 0) {
                let xp = 10;
                let gold = Math.floor(Math.random()*10) + 5;
                player.gold += gold;
                entities = entities.filter(e => e !== target);
                log(`Enemy slain! +${gold}g`);
            }
            
            tick(); // Enemy turn
        }

        function playerAction() {
            // Context sensitive button (Attack nearest or Heal)
            // For now, simple AOE attack for Mage, or just wait
            if(heroClass === 'MAGE') {
                // Fireball around
                entities.forEach(e => {
                    if(Math.abs(e.x - player.x) <= 2 && Math.abs(e.y - player.y) <= 2) {
                        e.hp -= player.atk * 0.8;
                        spawnParticle(e.x, e.y, "üî•", "#f50");
                    }
                });
                entities = entities.filter(e => e.hp > 0);
                tick();
            } else {
                log("Wait...");
                tick();
            }
        }

        function tick() {
            // Enemies move/attack
            entities.forEach(e => {
                if(e.type === 'chest') return;
                
                let dist = Math.abs(player.x - e.x) + Math.abs(player.y - e.y);
                
                if(dist === 1) {
                    // Attack player
                    player.hp -= e.atk;
                    spawnParticle(player.x, player.y, `-${e.atk}`, "#f00");
                    tg.HapticFeedback.notificationOccurred('warning');
                    if(player.hp <= 0) gameOver();
                } else if(dist < 5) {
                    // Move towards player
                    let dx = Math.sign(player.x - e.x);
                    let dy = Math.sign(player.y - e.y);
                    
                    // Simple pathfinding (try x, then y)
                    if(map[e.y][e.x+dx] !== 1 && !isBlocked(e.x+dx, e.y)) e.x += dx;
                    else if(map[e.y+dy][e.x] !== 1 && !isBlocked(e.x, e.y+dy)) e.y += dy;
                }
            });
            updateUI();
        }

        function isBlocked(x, y) {
            if(x===player.x && y===player.y) return true;
            return entities.some(e => e.x === x && e.y === y);
        }

        // --- RENDER ---
        function draw() {
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, cvs.width, cvs.height);

            // Camera Center
            camX = player.x * TILE - (cvs.width/2);
            camY = player.y * TILE - (cvs.height/2);

            // Draw Map
            let startCol = Math.floor(camX / TILE);
            let endCol = startCol + VIEW_W + 1;
            let startRow = Math.floor(camY / TILE);
            let endRow = startRow + VIEW_H + 1;

            for(let y = startRow; y < endRow; y++) {
                for(let x = startCol; x < endCol; x++) {
                    if(y >= 0 && y < mapH && x >= 0 && x < mapW) {
                        let tile = map[y][x];
                        let px = x * TILE - camX;
                        let py = y * TILE - camY;
                        
                        // Fog of War (Distance check)
                        let dist = Math.sqrt((player.x-x)**2 + (player.y-y)**2);
                        if(dist > 4) {
                            // Darkness
                            ctx.fillStyle = '#000';
                            ctx.fillRect(px, py, TILE, TILE);
                            continue;
                        }

                        // Floor/Wall
                        ctx.fillStyle = tile === 1 ? SPRITES.wall : SPRITES.floor;
                        ctx.fillRect(px, py, TILE, TILE);
                        
                        // Stairs
                        if(tile === 2) ctx.fillText(SPRITES.stairs, px+TILE/2, py+TILE/2);
                    }
                }
            }

            // Draw Entities
            entities.forEach(e => {
                let dist = Math.sqrt((player.x-e.x)**2 + (player.y-e.y)**2);
                if(dist <= 4) {
                    let px = e.x * TILE - camX + TILE/2;
                    let py = e.y * TILE - camY + TILE/2;
                    ctx.fillText(e.icon, px, py);
                    
                    // HP Bar
                    ctx.fillStyle = "red";
                    ctx.fillRect(px-10, py-14, 20, 3);
                    ctx.fillStyle = "#0f0";
                    ctx.fillRect(px-10, py-14, 20 * (e.hp/e.maxHp), 3);
                }
            });

            // Draw Player
            let pPx = player.x * TILE - camX + TILE/2;
            let pPy = player.y * TILE - camY + TILE/2;
            ctx.fillText(SPRITES.player, pPx, pPy);

            // Particles (Floating Text)
            particles.forEach((p, i) => {
                p.y -= 1; p.life -= 0.05;
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillText(p.txt, p.x - camX + TILE/2, p.y - camY);
                ctx.globalAlpha = 1;
                if(p.life <= 0) particles.splice(i, 1);
            });

            requestAnimationFrame(draw);
        }

        function spawnParticle(x, y, txt, color) {
            particles.push({x:x * TILE, y:y * TILE, txt, color, life:1.0});
        }

        function gameOver() {
            alert(`YOU DIED! Gold saved: ${Math.floor(player.gold/2)}`);
            tg.sendData(JSON.stringify({act:'end_run', gold:Math.floor(player.gold/2), depth:player.depth}));
            location.reload();
        }

        function log(msg) {
            const l = document.getElementById('log');
            const d = document.createElement('div');
            d.className = 'log-msg';
            d.innerText = `> ${msg}`;
            l.prepend(d);
            if(l.children.length > 3) l.lastChild.remove();
        }

        function updateUI() {
            document.getElementById('ui-hp').innerText = `${player.hp}/${player.maxHp}`;
            document.getElementById('bar-hp').style.width = `${(player.hp/player.maxHp)*100}%`;
            document.getElementById('ui-gold').innerText = `üí∞ ${player.gold}`;
            document.getElementById('ui-depth').innerText = `FLOOR ${player.depth}`;
        }

        // --- SHOP ---
        function showShop() { document.getElementById('modal-shop').style.display='flex'; }
        function buyGems(amt, prc) {
            tg.sendData(JSON.stringify({act:'buy_gems', amount:amt, price:prc}));
        }

        // --- INIT ---
        tg.sendData(JSON.stringify({act:'init'}));
        initCanvas();
        draw();

    </script>
</body>
</html>
